#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <errno.h>
#include <pthread.h>

// following code will be part of server.h - the header file

#define TCP_SERVER_ERROR_EXIT_CODE 54
#define BACKLOG_QUEUE_SIZE 100
// very very important part , the header file will contain struct declaration not defination
// following declaration are called forward declaration , definations will be in libaray

struct _tcp_server;
struct _tcp_client;

typedef struct _tcp_server tcp_server;
typedef struct _tcp_client tcp_client;

// core functions
tcp_server *allocate_tcp_server(unsigned short int);
void release_tcp_server(tcp_server *);
void tcp_start_server(tcp_server *);
void tcp_stop_server(tcp_server *);
void *request_processor(void *);

// error related functions
int tcp_server_failed(tcp_server *);
void tcp_server_error(tcp_server *, char **);

// functions for raising event
void raise_tcp_server_stopped_event(tcp_server *);
void raise_tcp_server_started_event(tcp_server *);

// functions for setting up event handler
void on_tcp_server_started(tcp_server *, void (*)(unsigned short int));
void on_tcp_server_stoppped(tcp_server *, void (*handler)(unsigned short int));
void on_tcp_client_connected(tcp_server *, void (*)(unsigned short int, tcp_client *));

// following code will be the part of server.c that will get compliled to a library

typedef struct _tcp_server
{
    unsigned short int port;
    int socket_descriptor;
    int socket_descriptor_closed;
    char error_type;
    int error_number;
    int keep_running;
    void (*on_tcp_client_connected)(unsigned short int, tcp_client *);
    void (*on_tcp_server_started)(unsigned short int);
    void (*on_tcp_server_stoppped)(unsigned short int);

} tcp_server;

typedef struct _tcp_client
{
    int socket_descriptor;
    struct sockaddr_storage client_sockaddr_storage;
    socklen_t client_sockaddr_size;

    struct _tcp_server *server;

} tcp_client;

tcp_server *allocate_tcp_server(unsigned short port)
{
    struct addrinfo hints;
    int failed_state;
    struct addrinfo *ptr2top_node;
    struct addrinfo *temp;
    tcp_server *server;
    char port_str[6];

    server = (tcp_server *)malloc(sizeof(tcp_server));
    if (server == NULL)
        return NULL;

    // structure of type (tcp_server) created
    // assigning default values

    /*
        error types
        none : ' '
        custom : 'C'
        predefined get address info : 'G'
        predefined but not get address info : 'P'

    */

    server->port = 0;
    server->socket_descriptor = 0;
    server->socket_descriptor_closed = 1; // yes , by default not opened , means closed
    server->error_number = 0;             // 0 means no error
    server->keep_running = 0;             //  default state is  false
    server->error_type = ' ';             // none by default
    server->on_tcp_client_connected = NULL;
    server->on_tcp_server_started = NULL;
    server->on_tcp_server_stoppped = NULL;

    // some validation
    if (port <= 0) // unsigned short int (0-65535) , really < not required == would do
    {
        server->error_number = 901; // Invalid port number
        server->error_type = 'C';
        return server;
    }
    server->port = port;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;

    sprintf(port_str, "%d", server->port);

    failed_state = getaddrinfo(NULL, port_str, &hints, &ptr2top_node);
    if (failed_state == -1)
    {
        server->error_number = errno;
        server->error_type = 'G';
        return server;
    }

    // lets traverse the linked list pointed to by ptr2top_node
    for (temp = ptr2top_node; temp != NULL; temp = temp->ai_next)
    {
        server->socket_descriptor = socket(temp->ai_family, temp->ai_socktype, temp->ai_protocol);
        if (server->socket_descriptor == -1)
            continue;
        server->socket_descriptor_closed = 0; // false , not closed as socket got created

        failed_state = bind(server->socket_descriptor, temp->ai_addr, temp->ai_addrlen);
        if (failed_state == -1)
        {
            close(server->socket_descriptor);
            server->socket_descriptor_closed = 1; // set to true ,as socket has been closed
            server->socket_descriptor = 0;
            continue;
        }
        break;
    } // loop to traverse the linked list ends here

    freeaddrinfo(ptr2top_node); // release the linked list generated by getaddrinfo

    if (temp == NULL) // socket creation or bind failed
    {
        server->error_number = 902;
        server->error_type = 'C'; // custom error
        return server;
    }

    failed_state = listen(server->socket_descriptor, BACKLOG_QUEUE_SIZE);
    if (failed_state == -1)
    {
        server->error_number = errno;
        server->error_type = 'P';
        close(server->socket_descriptor);
        server->socket_descriptor_closed = 1; // yes now closed
        return server;
    }

    // everything done , socket created , binding done , listen enabled
    return server;
}

void release_tcp_server(tcp_server *server)
{
    if (server == NULL)
        return;
    if (server->socket_descriptor == 0)
        close(server->socket_descriptor);
    free(server);
}

void tcp_start_server(tcp_server *server)
{
    int error_number;
    pthread_attr_t thread_attr;
    pthread_t thread_id;
    tcp_client *client;

    if (server == NULL)
        return;
    if (server->on_tcp_client_connected == NULL)
    {
        server->error_number = 903;
        server->error_type = 'C';
        return;
    }

    server->keep_running = 1; // set to true
    pthread_attr_init(&thread_attr);
    pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_DETACHED);

    if (server->on_tcp_server_started != NULL)
        raise_tcp_server_started_event(server);

    while (server->keep_running)
    {
        client = (tcp_client *)malloc(sizeof(tcp_client));
        if (client == NULL)
        {
            // this may happen on the nth cycle , we are in no position to accept the connection
            // as memoery is low
            // we can either try after some time or choose to leave
            // I choose to leave
            server->error_number = 904;
            server->error_type = 'C';
            break; //  break off from the infinite loop
        }

        client->client_sockaddr_size = sizeof(struct sockaddr_storage);
        client->socket_descriptor = accept(server->socket_descriptor, (struct sockaddr *)&(client->client_sockaddr_storage), &(client->client_sockaddr_size));

        if (client->socket_descriptor == -1)
        {
            free(client);
            server->error_number = errno;
            server->error_type = 'P';
            break; // unable to accept connection we can retry I choose to leave break off from loop
        }

        client->server = server;
        error_number = pthread_create(&thread_id, &thread_attr, request_processor, (void *)client);
        if (error_number != 0)
        {
            /*
                error number may be related to unable to create thread , or policy does not allow thread creation or invalid thread attributes (this cannot happen in our case)
                we will stick to one thing : unable to create thread , we can retry , I choose to leave , break off
            */
            free(client);
            server->error_number = 905;
            server->error_type = 'C';
            break;
        }
    } // infinite loop to accept the connection

    // when the control reaches here it means that the server wont accept any more request
    // hence server stopped but it should be well documented that running thread processing
    // connected client request wont be terminated

    if (server->on_tcp_server_stoppped != NULL)
    {
        raise_tcp_server_stopped_event(server);
    }
    // from here back to the caller function
}

void tcp_stop_server(tcp_server *server)
{
    if (server == NULL)
        return;
    server->keep_running = 0;
}

void *request_processor(void *gen_ptr)
{
    tcp_client *client;
    if (gen_ptr == NULL)
        return NULL;
    client = (tcp_client *)gen_ptr;
    client->server->on_tcp_client_connected(client->server->port, client);
    return NULL;
}

int tcp_server_failed(tcp_server *server) // returns true/yes (1) and no/false (0)
{
    if (server == NULL || server->error_number != 0)
        return 1; // yes something has failed
    return 0;     // not failed
}

void tcp_server_error(tcp_server *server, char **error_str)
{
    char *error901 = "Invalid port number";
    char *error902 = "Unable to create socket";
    char *error903 = "Client Handler not configured via on_tcp_client_connected_functions, refer documentation";
    char *error904 = "Low memory resources , cannot perform operations";
    char *error905 = "Unable to create connection handler because of low resources or insufficient thread permissions";
    if (server == NULL || error_str == NULL)
        return;
    if (server->error_number == 0)
    {
        *error_str = NULL;
        return;
    }
    if (server->error_type == 'G')
    {
        *error_str = (char *)malloc(sizeof(char) * (strlen(gai_strerror(server->error_number)) + 1));
        if (*error_str != NULL)
            strcpy(*error_str, gai_strerror(server->error_number));
    }
    else if (server->error_type == 'P')
    {
        *error_str = (char *)malloc(sizeof(char) * (strlen(strerror(server->error_number)) + 1));
        if (*error_str != NULL)
            strcpy(*error_str, strerror(server->error_number));
    }
    else if (server->error_type == 'C')
    {
        if (server->error_number == 901)
        {
            *error_str = (char *)malloc(sizeof(char) * (strlen(error901) + 1));
            if (*error_str != NULL)
                strcpy(*error_str, error901);
        }
        else if (server->error_number == 902)
        {
            *error_str = (char *)malloc(sizeof(char) * (strlen(error902) + 1));
            if (*error_str != NULL)
                strcpy(*error_str, error902);
        }
        else if (server->error_number == 903)
        {
            *error_str = (char *)malloc(sizeof(char) * (strlen(error903) + 1));
            if (*error_str != NULL)
                strcpy(*error_str, error903);
        }
        else if (server->error_number == 904)
        {
            *error_str = (char *)malloc(sizeof(char) * (strlen(error904) + 1));
            if (*error_str != NULL)
                strcpy(*error_str, error904);
        }
        else if (server->error_number == 905)
        {
            *error_str = (char *)malloc(sizeof(char) * (strlen(error905) + 1));
            if (*error_str != NULL)
                strcpy(*error_str, error905);
        }
        else
        {
            *error_str = NULL; // this will not happen
        }
    }
    else
    {
        *error_str = NULL; // this will not happen
    }
}
void raise_tcp_server_started_event(tcp_server *server)
{
    if (server == NULL)
        return;
    if (server->on_tcp_server_started != NULL)
        server->on_tcp_server_started(server->port);
}
void raise_tcp_server_stopped_event(tcp_server *server)
{
    if (server == NULL)
        return;
    if (server->on_tcp_server_stoppped != NULL)
        server->on_tcp_server_stoppped(server->port);
}

void on_tcp_server_started(tcp_server *server, void (*handler)(unsigned short int))
{
    if (server == NULL)
        return;
    server->on_tcp_server_started = handler;
}
void on_tcp_server_stoppped(tcp_server *server, void (*handler)(unsigned short int))
{
    if (server == NULL)
        return;
    server->on_tcp_server_stoppped = handler;
}

void on_tcp_client_connected(tcp_server *server, void (*handler)(unsigned short int, tcp_client *))
{
    if (server == NULL)
        return;
    server->on_tcp_client_connected = handler;
}

// the following code will be written by the serverside network layer library user
// lets assume the name of the prpgrammer to be Bobby
// we will remove the followig code , while creating library ,
// as library should not contain main function , that is supposed to be written by library user
// we are writing it right now , just to test our code

void tcp_server_started_handler(unsigned short int server_port)
{
    // code that will be executed when server starts (one time act only)
    printf("Server is ready to accept the request on port : %u\n", server_port);
}

void tcp_server_stoppped_handler(unsigned short int server_port)
{
    // code that will be executed when server stops (one time act only)
    printf("Server listening on port %u has stopped\n", server_port);
}

void tcp_server_client_connected_handler(unsigned short int server_port, tcp_client *connected_client)
{
    // code that will be executed whenever a connection is accepted
    printf("Server listening on port %u has accepted connection request\n", server_port);
}

int main()
{
    char *error_str;
    tcp_server *server;
    server = allocate_tcp_server(5046); // Bobby may write code to pick port number from some file
    if (tcp_server_failed(server))
    {
        release_tcp_server(server);
        tcp_server_error(server, &error_str);
        if (error_str != NULL)
        {
            printf("%s\n", error_str);
            free(error_str);
        }
        exit(TCP_SERVER_ERROR_EXIT_CODE); // application terminates with an error code (non zero)
    }

    // server allocated to accept request on 5046, not yet accepting connection

    // setting up some handlers
    on_tcp_server_started(server, tcp_server_started_handler);
    on_tcp_server_stoppped(server, tcp_server_stoppped_handler);
    on_tcp_client_connected(server, tcp_server_client_connected_handler);

    // starting the server
    tcp_start_server(server); // now the server is in waiting mode to accept the connection
    if (tcp_server_failed(server))
    {
        release_tcp_server(server);
        tcp_server_error(server, &error_str);
        if (error_str != NULL)
        {
            printf("%s\n", error_str);
            free(error_str);
        }
        pthread_exit(NULL); // lets not terminate the running threads
    }
    else
    {
        release_tcp_server(server);
    }
    pthread_exit(NULL); // so that running thread wont terminate
}